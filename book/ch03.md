# 변수와 데이터 타입

### 변수의 유효 범위와 생애주기
- 변수는 변수가 선언된 내용에 따라 나름의 참조 가능한 유효범위와
  생명주기를 가진다는 특징이 있다.
- 변수에 어떤 내용을 할당함으로써 해당 내용을 참조하는 코드가 이 부분을
  알 수 있고, 맡은 동작을 수행할 때까지 유지된다.
- 스위프트 파일구조에서 변수는 코드 내 어느 위치에서든 선언될 수 있다.
- 전역 변수
  - 전역 변수는 스위프트 파일의 최상위 레벨에 선언한다.
  - 전역 변수 생명주기는 스위프트 파일의 생명주기만큼 유지된다.
  - 동일 모듈에 들어있는 스위프트 파일은 자동으로 서로를 확인할 수 있다.
- 프로퍼티
  - 프로퍼티는 enum, struct, class 등 객체 타입 선언의 최상위 레벨에
    선언된 변수다.
  - 인스턴스 프로퍼티
    - 기본적으로 프로퍼티라 불리는 것은 인스턴스 프로퍼티를 가리킨다.
    - 이것이 지닌 값은 해당 객체 타입의 인스턴스에 따라 달라진다.
    - 생명주기는 인스턴스의 생명주기를 따른다.
  - 정적&#47;클래스 프로퍼티
    - static 또는 classs 라는 키워드와 함께 선언된 프로퍼티를 정적
      프로퍼티 혹은 클래스 프로퍼티라고 한다.
    - 생명주기는 객체 타입의 생명 주기와 같다.
    - 특정 객체 타입이 파일의 최상위 레벨에 선언되거나 다른 객체 타입의
      최상위에 선언될 경우, 프로그램이 실행되는 동안 영구히 존재할 수
있다.
    - 객체 메소드는 self 키워드를 통해 해당 객체의 프로퍼티를 볼 수 있다.
    - 다른 코드를 보기 위해서는 점표기법을 사용한다.
- 지역 변수
  - 함수 몸체 내부에 선언된 변수다. 생명주기는 중괄호로 감싼 유효 범위의
    생명주기를 따른다.
  - 지역변수는 동일 유효 범위 내의 후속 코드만 볼 수 있다.

### 변수 선언
- 변수 선언 방식에는 let 을 이용하는 경우와 var 를 이용하는 경우가 있다.
- let 변수는 상수가 되며, 초기화를 통해 할당된 값은 변경할 수 없다.
- var 변수는 일반적인 변수를 뜻하며, 초기화된 뒤에도 값을 변경할 수
  있다. 하지만, 변수의 타입은 바꿀 수 없다.
- 명시적인 변수 타입 선언
  - 변수 선언 시 변수 이름 뒤에 &#58; 을 추가하고 타입 명을 쓴다.
```swift
var x: Int
```
- 초기화를 통한 묵시적인 변수 타입 부여
  - 변수 선언과 동시에 초기 값을 할당하는 경우, 컴파일러가 자동으로
    타입을 부여한다.
```swift
var s = 1 // x: Int
```
  - 물론, 명시적으로 변수의 타입을 선언하면서 초기 값을 할당하는 것도
    가능하다.
```swift
var s: Int = 1
```
__초기 값을 할당하면서 타입을 명시적으로 선언하는 일이 필요한 경우__
  - 스위프트 변수 타입에 대한 판단이 틀린 경우
    - 변수 초기값을 숫자로 할당할 때 겪게 되는 상황이다.
    - 스위프트는 소수점 유무에 따라 Int 나 Double 타입으로 판단한다.
```swift
let separator: CGFloat = 2.0
```
__스위프트가 변수 타입을 추측할 수 없는 경우__
  - 명시적인 변수 타입은 해당 타입의 초기 값을 추측할 수 있도록 한다.
  - 아래 코드는 컴파일 되지 않는 코드 예제이다.
```swift
var opts = [.Autoreverse, .Repat] // 컴파일 오류
```
  - 오류 이유는 .Autoreverse 와 .Repeat 가 각각
    UIViewAnimationOptions.Autoreverse 와 UIviewAnimationOptions.Repeat 의
  단축어로 사용되기 때문이다.
  - (스위프트는 이런 사실을 알려주기 전까지는 이런 내용을 모른다.)
__프로그래머가 타입을 추측할 수 없는 경우__
```swift
let duration: CMTime = track.timeRange.duration
```
  - 위 코드에서 track 은 AVAssetTrack 의 인스턴스다. 스위프트는
    AVAssetTrack 의 timeRange 프로퍼티의 영상 재생 시간과 관련된
  프로퍼티가 CMTime 임을 알지만, 코드를 짠 개발자는 며칠 후 이를 기억 못할
  수도 있다.

- 명시적인 변수 타입 선언이 가능하므로 변수를 선ㅇ언하면서 반드시
  초기화할 필요가 없다.
- 대부분 명시적인 타입 선언과 함께 초기 값을 할당하길 추천하지만, 몇
  가지 예외 상황이 있다.
- 변수는 단 한 번만 선언해야 하는데 조건문을 사용할 경우, 조건에 따른
  초기화는 그 이후에 일어나기 때문에 확정하기 어렵다. (다음은 좋지 않은
코드 예이다.)
```swift
let timed: Bool
if val == 1 {
  timed = true
} else if val == 2 {
  timed = false
}
```
- 함수의 인수로 변수를 전달하는 경우에도 비슷한 상황이 발생할 수 있다.
```swift
var arrow = CGRectZero
var body = CGRectZero
CGRectDivide(rect, &arrow, &body, Arrow.ARHEIGHT, .MinYEdge)
```
- 두 개의 CGRectZero 값을 바꾸는 코드에서 임의로 할당한 초기 값은 임시
  저장소의 역할을 한다.
```swift
func beginBackgroundTaskWithExpirationHandler(handler: () -> void)
    -> UIBackgroundTaskIdentifier
```
- 위 함수는 숫자를 반환하며 이 숫자는 함수를 통해 handler 객체에
  전달된다.
- 스위프트에서는 이 숫자를 지니고 있다가 동일한 코드 라인에 있는 익명
  함수에서 사용하도록 선언할 수 없다.
```swift
let bti = UIApplication.sharedApplication()
    .beginBackgroundTaskWithExpirationHandler({
      UIApplication.sharedApplication().endBackgroundTask(bti)

}) // 오류 : 변수 스스로 초기 값 사용
```
- 따라서 변수를 미리 선언해야 하지만, 여전히 아래 코드는 에러가
  발생한다.
```swift
var bti: UIBackgroundTaskIdentifier
bti = UIApplication.sharedApplication()
    .beginBackgroundTaskWithExpirationHandler({
      UIApplication.sahredApplication().endBackgroundTask(bti)
})
```
- 변수를 미리 선언하되, 임의 초기 값을 할당하는 것이다.
```swift
var bti: UIBackgroundTaskIdentifier = 0
bti = UIApplication.sharedApplication()
    .beginBackgroundTaskWithExpirationHandler({
      UIApplication.sahredApplication().endBackgroundTask(bti)
})
```

### 컴퓨터 연산에 의한 초기화
```swift
let timed: Bool = {
  if val == 1 {
    return true
  } else if val == 2 {
    return false
  }
}()
```
- 이와 같은 방식을 인스턴스 프로퍼티를 초기화할 때도 사용할 수 잇다.
- 여러번 사용할 UIImage 를 위해 클래스에서 상수인 인스턴스 프로퍼티를
  만든다.
```swift
class RootViewController: UITableViewController {
  let cellBackgroundImage: UIImage = {
    return imageOfSize(CGSizeMake(320, 44)) {
      // 그림 그리기 코드
    }
  }()
}
```

### 컴퓨터 연산에 의한 변수 생성
- 기존의 변수와 다른 방식으로도 함수를 만들수 있다. 바로 컴퓨터 연산에
  의한 변수 생성 방식을 이용하는 것이다.
- 이때는 변수가 값을 지니는 것이 아니라 함수를 지니게 된다. 이를 위한
  하나의 함수가 바로 &lsquo;setter&rsquo; 이며 변수를 할당할 때
호출된다. 또다른 함수는 &lsquo;getter&rsquo; 이며 변수를 참조할 때
호출된다.
```swift
var now: String { // 1
  get { // 2
    return NSDate().description // 3
  }
  set { // 4
    println(newValue) // 5
  }
}

var str: String = now // 2016-04-25 15:31:37 +0000
now = "Howdy" // Howdy

```
  - 1. 변수는 반드시 var 여야하고, 타입은 명시적으로 선언해야한다.
    중괄호가 필요하다.
  - 2. getter 는 get 으로 호출되며, 중괄호 안에 함수 내용을 작성한다.
  - 3. 변수와 동일한 타입의 값을 반환해야 한다.
  - 4. setter 는 set 으로 호출되며, 중괄호 안에 함수의 내용을 작성한다.
  - 5. setter 는 하나의 파라미터가 있는 함수와 비슷한 기능을 수행한다. 이
    코드에서는 newValue 라는 지역 변수를 setter 의 파라미터로 받았다.
- 컴퓨터 연산에 의해 생성된 변수는 다음과 같이 활용한다.
```swift
now = "Howdy" // 1
println(now) // 2
```
  - 1. 변수 now 에 할당하는 것을 setter 라고 한다. 이 호출에서 전달된
    "Howdy" 라는 인수 자체가 할당된 값이다. 이 값이 newValue 로써 set 에
전달된다. 이번 set 함수는 콘솔에 newValue 를 출력한다.
  - 2. 변수 now 를 참조하는 것을 getter 라고 한다. 이번 get 함수는 현재
    날짜 및 시간을 가져와 문자열로 반환하며, 이번 get 함수는 콘솔에
날짜&#45; 시간을 출력한다.
  - 변수 now 에 &ldquo;Howdy&rdquo;를 할당했지만 &ldquo;Howdy&rdquo;
    대신 날짜 &#45; 시간 이 출력되는 것을 볼 수 있다. set 함수는 값을
저장할 수는 있지만 컴퓨터로 생성한 변수에 해당 값을 저장해둘 수는 없다.
  - 컴퓨터로 생성한 변수는 값의 저장소로 사용할 수 없고, setter,
    getter 함수 호출을 위한 이름으로 사용된다.
  - set 함수 파라미터 이름은 newValue 가 아니어도 된다. 다른 이름을 붙일
    경우 다음과 같이 소괄호 안에 입력한다.
```swift
set (val) {
  // Use val
}
```
  - setter 는 없으면 읽기만 가능한 read&#45;only 변수가 된다. 이때 값을
    할당하려하는 경우 컴파일 오류가 발생한다. (읽기 전용 변수를 만드는
가장 대표적인 방법이다.)
  - getter 는 꼭 있어야한다. 만일 setter 를 사용하지 않으려면 get
    키워드와 중괄호 모두 생략한다.
```swift
var now: String {
  return NSDate().description
}
```
  - 컴퓨터 생성 변수는 다양한 용도로 사용된다.
    - 읽기만 가능한 변수가 필요할 때 : 읽기만 가능한 변수는 대체로 전역
      변수 또는 프로퍼티로 사용된다.
    - 함수를 표현하기 위한 용도 : 필요에 따라 함수를 통해 특정 값을
      계산해서 전달해야 하는 경우, 읽기만 가능한 변수를 사용할 수 있다.
```swift
var mp: MPMusicPlayerController {
  return MPMusicPlayerController.systemMusicPlayer()
}
// 참조가 필요할 때마다 mp 라는 간단한 이름으로 해당 함수의 값을 참조할 수 있다.
```
    - 다른 변수를 표현하기 위한 용도 : 컴퓨터 생성 변수는 하나 이상의
      저장 변수를 대표할 수 있으며, 이들 저장 변수의 설정과 참조 방식을
설명할 수 있는 문지기와 같은 역할을 수행한다.
```swift
private var _p: String = ""
var p: String {
  get {
    return self._p
  }
  set {
    self._p = newValue
  }
}
// private 저장 변수를 직접 설정하거나 가져오기만 하므로 p 와 _p 는 별 차이 없지만,
// 이 방식을 통해 getter 와 setter 작업이 이루어지는 동안 어떠한 기능을 추가할 수도 있다.
```
- 다음은 컴퓨터 생성 변수를 표현하기 위한 대표적인 예제 코드로 디스크에
  저장된 값을 조회한 뒤 이 값을 가져온다.
```swift
var myBigData: NSData! {
  set (newData) {
    self.myBigDataReal = newdata
  }
  get {
    if myBigDataReal == nil {
      // f 파일 또는 디스크 참조
      self.myBigDataReal = NSData(contentsOfFile: f)
      // 파일 삭제
    }
  }
}
```

### 세터 옵저버
- 컴퓨터 생성 변수를 다른 저장 변수를 표현하는 용도로 사용하는 경우는
  많지 않다. 저장 변수의 세터 내부에 이와 같은 기능을 삽입할 수 있는
&lsquo;Setter Observer&rsquo; 기능이 있기 때문이다.
- 세터 옵저버는 다른 저장 변수를 설정하는 코드의 직전 &#47; 직후 에
  호출된다.
```swift
var s = "whatever" { // 1
  willSet { // 2
    println(newValue) // 3
  }
  didSet { // 4
    println(oldValue) // 5
    // self.s = "something else"
  }
}
```
  - 1. 변수는 var 이어야 하고, 변수 타입은 명시적으로 선언해야한다. 초기
    값을 할당할 수 있으며, 다음 중괄호를 입력한다.
  - 2. willSet 함수는 다른 코드가 이 변수를 설정할 때, 그리고 이 변수가
    새로운 값을 받기 직전 호출된다.
  - 3. weillSet 함수는 newValue 로 들어오는 새로운 값을 받는다. newValue
    대신 다른 이름을 사용하려면 willSet (바꾸고자 하는 이름) 이라 쓴다.
기존의 값은 저장 변수에 여전히 남아 있이며, willSeet 함수는 필요에 따라
기존 값에 접근할 수 있다.
  - 4. didSet 함수는 다른 코드가 이 변수를 설정할 때, 그리고 이 변수가
    새로운 값을 받은 직후 호출된다.
  - 5. oldValue 는 새로운 값으로 대체된 기존 값을 입력받는다. oldValue
    대신 다른 이름을 사용하려면 didSet (바꾸고자 하는 이름) 이라고 쓴다.
새로운 값은 이미 저장 변수에 입력돼 있으며, didSet 함수는 필요에 따라
새로운 값에도 접근할 수 있다. didSet 함수를 통해 변수에 다른 값을
설정하는 것도 가능하다.
- 세터 옵저버 함수는 저장 변수가 초기화되거나 didSet 함수가 저장 변수의
  값을 변경하는 경우에는 호출되지 않는다.
- 마스터&#45;디테일 애플리케이션 템플릿을 구현하기 위한 코드로 프로퍼티
  설정의 결과로 인터페이스의 형태를 변경한다.
```swift
var detailItem: AnyObject? {
  didSet {
    // 뷰 업데이트
    self.configureView()
  }
}
```
- 위 코드는 뷰 컨트롤러 클래스의 인스턴스 프로퍼티다. 이 프로퍼티가 바뀔
  때마다 인터페이스가 바뀐다.
- 이 프로퍼티가 바뀔 때마다 인터페이스가 바뀌며, 프로퍼티 값을
  지속적으로 표시하기 위한 목적을 가진다.
- 인스턴스 메소드는 프로퍼티 값을 읽고 인터페이스는 이에 따라 내용을
  달리 표시한다.
```swift
var angle: CGFloat = 0 {
  disSet {
    // angle 은 0보다 작거나 5보다 커서는 안 된다.
    if self.angle < 0 {
      self.angle = 0
    }
    if self.angle > 5 {
      self.angle = 5
    }
    // 각도 값에 맞춰 인터페이스 수정
    self.transform = CGAffineTransformMakeRotation(self.angle)
  }
}
```
- 컴퓨터 생성 변수는 세터 옵저버를 지닐 수 없다. 세터 함수만 있으면
  프로그램에서 요구되는 어떤 역할이든 부여할 수 있기 때문이다.

### 지연 초기화
- 선언 내용의 일부로써 저장 변수가 초기 값으로 할당되거나, 지연 초기화
  기법을 사용하면 실제 코드가 해당 변수의 값에 접근하기 전까지 초기 값은
실제로 계산되거나 할당되지 않는다.
- 지연 초기화가 가능한 세 가지 타입의 변수는 다음과 같다.
  - 전역 변수 : 전역 변수는 기본적으로 지연 초기화를 한다. 예를 들어, 앱
    실행 시 실제 실행 전까지는 변수가 초기화되지 않다가, 실행되는 순간
초기화된다. 이때, dispatch&#95;once 키워드를 통해 지연 초기화를 보장받을
수 있다.
  - 정적 프로퍼티 : 정적 프로퍼티 역시 전역 변수와 동일한 방식으로
    작동한다. (저장 클래스 프로퍼티는 없으므로 클래스 프로퍼티는
초기화될 수 없고, 지연 초기화 역시 불가능하다.)
  - 인스턴스 프로퍼티 : 기본적으로 지연 초기화를 하지 않지만, lazy
    키워드를 사용하면 지연 초기화할 수 있다.  이때, 프로퍼티는 var
이어야 한다. 이 같은 초기화 함수는 값을 계산하지 않으며 다른 코드가 해당
프로퍼티 값을 요구하기 전까지는 해당 값을 할당하지 않는다. 또한, 싱글톤
구현에 자주 사용된다.
```swift
class MyClass {
  static let sharedMyClassSingleton = myClass()
}
```

